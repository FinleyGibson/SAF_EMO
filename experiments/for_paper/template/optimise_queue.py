# from multiprocessing.pool import ThreadPool
from multiprocessing import cpu_count
from threading import Thread
from generate_queue import n_opt
import persistqueue

import logging
import rootpath
import sys
sys.path.append(rootpath.detect())
import testsuite

# get processor count
proc_count = cpu_count()
# cap processor usage
try:
    m_proc = sys.argv[1]
except IndexError:
    m_proc = proc_count

# set number of available processors
n_proc = min(proc_count, m_proc)

#q = persistqueue.SQLiteAckQueue('./opt_queue', multithreading=True)
#print("loaded que of {} items from ./opt_queue".format(q.size))

# def perpetual_optimise():
#     while not q.empty():
#         optimiser = q.get()
#         try:
#             optimiser.optimise()
#             q.ack(optimiser)
#         except Exception as e:
#             logging.error("an error occured: "+str(e))
#             q.nack(optimiser)
#             raise RuntimeError
# 
def perpetual_optimise():
    q = persistqueue.SQLiteAckQueue('./opt_queue', multithreading=True)
    while not q.empty():
        optimiser = q.get()
        optimiser.optimise()
        q.ack(optimiser)
        q = persistqueue.SQLiteAckQueue('./opt_queue', multithreading=True)

#print("{} processors found, limited to access {} processors.".format(proc_count, n_proc))
#print("{} optimsations found in queue, of {} generated by generate_queue.py in its current state.".format(q.size, n_opt))
cont = input("Press Enter to begin, optimisation, input N to cancel:\t").lower()

logging.basicConfig(filename='error.log',level=logging.INFO)
if cont != "n":
    for i in range(n_proc):
        print(i)
        t = Thread(target=perpetual_optimise)
        t.daemon = False
        t.start()
    
    t.join()


